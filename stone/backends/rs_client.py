from __future__ import absolute_import, division, print_function, unicode_literals

_MYPY = False
if _MYPY:
    import typing  # noqa: F401 # pylint: disable=import-error,unused-import,useless-suppression
    from stone.ir import ApiNamespace  # noqa: F401 # pylint: disable=unused-import

# Hack to get around some of Python 2's standard library modules that
# accept ascii-encodable unicode literals in lieu of strs, but where
# actually passing such literals results in errors with mypy --py2. See
# <https://github.com/python/typeshed/issues/756> and
# <https://github.com/python/mypy/issues/2536>.
import importlib
argparse = importlib.import_module(str('argparse'))  # type: typing.Any

from stone.backend import CodeBackend
from stone.backends.js_helpers import (
    check_route_name_conflict,
    fmt_error_type,
    fmt_func,
    fmt_obj,
    fmt_type,
    fmt_url,
)

_cmdline_parser = argparse.ArgumentParser(prog='rs-client-backend')
_cmdline_parser.add_argument(
    'filename',
    help=('The name to give the single Rust file that is created and '
          'contains all of the routes.'),
)

_header = """\
// Auto-generated by Stone, do not modify.
"""


class RustClientBackend(CodeBackend):
    """Generates a single Rust file with all of the routes defined."""

    cmdline_parser = _cmdline_parser

    # Instance var of the current namespace being generated
    cur_namespace = None  # type: typing.Optional[ApiNamespace]

    preserve_aliases = True

    def generate(self, api):
        # first check for route name conflict
        with self.output_to_relative_path(self.args.filename):
            self.emit_raw(_header)
            for namespace in api.namespaces.values():
                # Hack: needed for _docf()
                self.cur_namespace = namespace
                check_route_name_conflict(namespace)

                if len(namespace.routes) == 0: continue
                with self.block('trait %s' % (namespace.name,)):
                    for route in namespace.routes:
                        self._generate_route(api.route_schema, namespace, route)

    def _generate_route(self, route_schema, namespace, route):
        function_name = fmt_func(namespace.name + '_' + route.name, route.version)
        def val(a, b):
            return b or ''
        if route.doc:
            self.emit_wrapped_text(self.process_doc(route.doc, val), prefix='/// ')
        if route.deprecated:
            self.emit('#[deprecated]')
        with self.block('fn %s(&mut self, arg: &%s)' % (route.name.replace('/', '_'), route.arg_data_type.name,)):
            url = fmt_url(namespace.name, route.name, route.version)
            self.emit("self.request(\"%s\", arg)" % (url,))
